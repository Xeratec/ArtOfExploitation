/*
* @file toolbox.h
* @author Philip Wiese
* @date 04 Okt 2016
* @brief Toolbox mit nützlichen Funktionen in C.
*
* Toolbox mit nütlichen Funktionen, von simplen I/O  
* bis zu netzwerkspezifischen Funktionen.
*
*/

//######################## Misc ########################//
//--------------------  Definitions --------------------//
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>

//--------------------- Functions ----------------------//
/*	This function accepts pointer to a message.
* 	It will print the message end exits the function.
*/
void fatal(char *message) {
	char error_message[100];
	
	strcpy(error_message, "[!!] Fatal Error ");
	strncat(error_message, message, 82);
	strncat(error_message, "\n", 1);
	perror(error_message);
	exit(EXIT_FAILURE);
}

/*	This function accepts a size. It will allocate <size> bytes of memory
*	and perform a errorchecking. 
*	It returns on success a pointer to the memory.
*/
void *ec_malloc(unsigned int size) {
	void *ptr;
	ptr = malloc(size);
	if (ptr == NULL) fatal("in ec_malloc() on memory allocation");
	return ptr;
}

// Dumps raw memory in hex bytes and printable split format
/* This function accepts a pointer to a buffer, a length and an optional 
*  number of tabs it should print before each line. It will display the raw 
*  buffer in hex bytes and displays printable ASCII charachters.
*/
void dump(const unsigned char *buffer, const unsigned int length, /* Optional const int flags */ ...) {
	unsigned char byte;
	unsigned int i,j,k;
	
	va_list ap;
   va_start(ap, length);
	const unsigned int tabs = va_arg(ap, int);
	
	
	for (i=0; i<length; i++) {
		if ( ( (i%16) == 0)) {
			for (k=0; k<tabs; k++)
				printf("\t");
		}
		printf("%02x ", buffer[i]);
		if ( ( (i%16) == 15) || (i==length-1)) {
			for (j=0; j<15-(i%16); j++) printf("   ");
			printf("| ");
			for (j=(i-(i%16)); j<=i; j++) { // Display printable bytes from line
				byte = buffer[j];
				if ((byte>31) && (byte<127)) 
					printf("%c", byte);
				else
					printf(".");
			}
			printf("\n");
		}
	}
}

//##################### Networking #####################//
//--------------------  Definitions --------------------//
#ifdef IMPORT_NETWORKING
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define ETHER_ADDR_LEN 6
#define ETHER_HDR_LEN 14

struct ether_hdr {
	unsigned char ether_dst_addr[ETHER_ADDR_LEN];
	unsigned char ether_src_addr[ETHER_ADDR_LEN];
	unsigned short ether_type;
};

struct ip_hdr {
	unsigned char ip_version_and_header_length;
	unsigned char ip_tos;				// Type of service
	unsigned short ip_len;				// Total length
	unsigned short ip_id;				// Identification number
	unsigned short ip_frag_offset; 	// Fragment offset and flags
	unsigned char ip_ttl; 				// Time to live
	unsigned char ip_type;				// Protocol type
	unsigned short ip_checksum	;		// Checksum
	unsigned int ip_src_addr;			// Source IP address
	unsigned int ip_dst_addr;			// Destination IP address
};

struct tcp_hdr {
	unsigned short tcp_src_port;		// Source TCP port
	unsigned short tcp_dst_port;		// Destination TCP port
	unsigned int tcp_seq;				// TCP sequence number
	unsigned int tcp_ack;				// TCP acknowledgment number
	unsigned char reserved:4;			// 4 bits of reserved space
	unsigned char tcp_offset:4;		// TCP data offset for little-endian
	unsigned char tcp_flags;			// TCP flags
	
	#define TCP_FIN 0x01
	#define TCP_SYN 0x02
	#define TCP_RST 0x04
	#define TCP_PUSH 0x08
	#define TCP_ACK 0x10
	#define TCP_URG 0x20
	
	unsigned short tcp_window;			// TCP windows size
	unsigned short tcp_checksum;		// TCP checksum
	unsigned short tcp_urgent;			// TCP urgent pointer
};

//--------------------- Functions ----------------------//
/* This function accepts a socket FD and a pointer to the null terminated 
*  string to send. The function will make sure all the bytes of the string
*  are send. Returns 1 on success and 0 on failure.
*/
int send_string(int sockfd, unsigned char *buffer) {
	int send_bytes, bytes_to_send;
	bytes_to_send=strlen(buffer);
	
	while (bytes_to_send > 0) {
		send_bytes = send(sockfd, buffer, bytes_to_send, 0);
		if (send_bytes == -1)
			return 0;
		bytes_to_send -= send_bytes;
		buffer += send_bytes;
	}
	return 1;
}

/* This function accepts a socket FD and a pointer to a destination buffer.
*  It will recieve from the socket until the EOL byte sequense is seen. 
*  The EOL bytes are read from the socket, but the destination buffer is 
*  terminated before these bytes.
*  Returns the size of the read line (without the EOL byte)
*/
int recv_line(int sockfd, unsigned char *dest_buffer) {
	#define EOL "\r\n"
	#define EOL_SIZE 2
	unsigned char *ptr;
	int eol_matched = 0;
	
	ptr = dest_buffer;
	while (recv(sockfd, ptr, 1, 0) == 1) {	// Read single byte
		if (*ptr == EOL[eol_matched]) {		// Does byte matches EOL
			eol_matched++;
			if (eol_matched = EOL_SIZE) {
				*(ptr+1-EOL_SIZE) = '\0';		// Terminate the string
				return strlen(dest_buffer);
			}
		} else {
			eol_matched = 0;
		}
		ptr++;
	}
	return 0;										// Didn't find the eol character
}

/* This function accepts a pointer to a dest_buffer and a pointer to a 
*  hostname. It will perform a hostlookup and and saves the resolved 
*  ip in the dest_buffer as an ASCII string containing the IP address in 
*  dottet-number format.
*  Returns 1 on success and 0 on failure.
*/
int host_lookup(unsigned char *dest_buffer, unsigned char *hostname) {
	struct hostent *host_info;
	struct in_addr *address;
	
	host_info = gethostbyname(hostname);
	if (host_info == NULL) {
		printf("[!!] Error in host_lookup() while lookup \"%s\"\n", hostname);
		return 0;
	} else {
		address = (struct in_addr *) (host_info->h_addr);
		strcpy(dest_buffer, inet_ntoa(*address));
	}
	return 1;
}
#endif
