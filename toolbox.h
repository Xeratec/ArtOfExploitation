/*
* @file toolbox.h
* @author Philip Wiese
* @date 28 Sep 2016
* @brief Toolbox mit nützlichen Funktionen in C
*
* Toolbox mit nütlichen Funktionen, von simplen I/O  
* bis zu netzwerkspezifischen Funktionen.
*
*/

//######################## Misc ########################//
// Zeigt eine Fehlermeldung und beendet das Programm
void fatal(char *message) {
	char error_message[100];
	
	strcpy(error_message, "[!!] Fatal Error ");
	strncat(error_message, message, 83);
	perror(error_message);
	exit(-1);
}

// Errorchecking Malloc Funktion
void *ec_malloc(unsigned int size) {
	void *ptr;
	ptr = malloc(size);
	if (ptr == NULL) fatal("in ec_malloc() on memory allocation");
	return ptr;
}

// Dumps raw memory in hex bytes and printable split format
void dump(const unsigned char *buffer, const unsigned int length) {
	unsigned char byte;
	unsigned int i,j;
	
	for (i=0; i<length; i++) {
		printf("%02x ", buffer[i]);
		if ( ( (i%16) == 15) || (i==length-1)) {
			for (j=0; j<15-(i%16); j++) printf("   ");
			printf("| ");
			for (j=(i-(i%16)); j<=i; j++) { // Display printable bytes from line
				byte = buffer[j];
				if ((byte>31) && (byte<127)) 
					printf("%c", byte);
				else
					printf(".");
			}
			printf("\n");
		}
	}
}

//##################### Networking #####################//
/* This function accepts a socket FD and a pointer to the null terminated 
*  string to send. The function will make sure all the bytes of the string
*  are send. Returns 1 on success and 0 on failure.
*/
int send_string(int sockfd, unsigned char *buffer) {
	int send_bytes, bytes_to_send;
	bytes_to_send=strlen(buffer);
	
	while (bytes_to_send > 0) {
		send_bytes = send(sockfd, buffer, bytes_to_send, 0);
		if (send_bytes == -1)
			return 0;
		bytes_to_send -= send_bytes;
		buffer += send_bytes;
	}
	return 1;
}

/* This function accepts a socket FD and a pointer to a destination buffer.
*  It will recieve from the socket until the EOL byte sequense is seen. 
*  The EOL bytes are read from the socket, but the destination buffer is 
*  terminated before these bytes.
*  Returns the size of the read line (without the EOL byte)
*/
int recv_line(int sockfd, unsigned char *dest_buffer) {
	#define EOL "\r\n"
	#define EOL_SIZE 2
	unsigned char *ptr;
	int eol_matched = 0;
	
	ptr = dest_buffer;
	while (recv(sockfd, ptr, 1, 0) == 1) {	// Read single byte
		if (*ptr == EOL[eol_matched]) {		// Does byte matches EOL
			eol_matched++;
			if (eol_matched = EOL_SIZE) {
				*(ptr+1-EOL_SIZE) = '\0';		// Terminate the string
				return strlen(dest_buffer);
			}
		} else {
			eol_matched = 0;
		}
		ptr++;
	}
	return 0;										// Didn't find the eol character
}

/* This function accepts a pointer to a dest_buffer and a pointer to a 
*  hostname buffer. It will perform a hostlookup and and saves the resolved 
*  ip in the dest_buffer as an ASCII string containing the IP address in 
*  dottet-number format.
*  Returns 1 on success and 0 on failure.
*/
int host_lookup(unsigned char *dest_buffer, unsigned char *hostname) {
	struct hostent *host_info;
	struct in_addr *address;
	
	host_info = gethostbyname(hostname);
	if (host_info == NULL) {
		printf("[!!] Error in host_lookup() while lookup \"%s\"\n", hostname);
		return 0;
	} else {
		address = (struct in_addr *) (host_info->h_addr);
		strcpy(dest_buffer, inet_ntoa(*address));
	}
	return 1;
}

