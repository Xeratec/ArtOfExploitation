/**
* @file decode_sniff.h
* @author Philip Wiese
* @date 04 Okt 2016
* @brief This programm sniffs raw TCP packets with libpcap and decodes and
*			dumps them.
* 
*/

#define IMPORT_NETWORKING

#include <pcap.h>
#include <unistd.h>
#include <ctype.h>
#include "toolbox.h"

void pcap_fatal(const char *, const char*);
void print_usage(int, char **);

void decode_ethernet(const u_char *);
void decode_ip(const u_char *);
u_int decode_tcp(const u_char *);

void caught_packet(u_char *, const struct pcap_pkthdr *, const u_char *);

int main (int argc, char *argv[])
{
	struct pcap_pkthdr cap_header;
	const u_char *packet, *pkt_data;
	char errbuf[PCAP_ERRBUF_SIZE];
	char *device, *cvalue = NULL;
	int c, pack_count=-1;
	pcap_t *pcap_handle;
	
	device = pcap_lookupdev(errbuf);
	
	opterr = 0;
	while ((c = getopt (argc, argv, "hc:d:")) != -1)
    switch (c)
      {
      case 'h':
			print_usage(argc, argv);
			return 1;
        	break;
      case 'c':
   		pack_count = (int) strtol(optarg, NULL, 10);
   		if (pack_count==0) {
      		fprintf (stderr, "Option -%c requires a numerical argument.\n", optopt);
      		exit(-1);
      	}
		   break;
      case 'd':
		   device = optarg;
		   break;
		case '?':
         if (optopt == 'c')
           fprintf (stderr, "Option -%c requires a numerical argument.\n", optopt);
         else if (optopt == 'd')
           fprintf (stderr, "Option -%c requires a device.\n", optopt);
         else if (isprint (optopt))
           fprintf (stderr, "Unknown option `-%c'.\n", optopt);
         else {
           fprintf (stderr, "Unknown option character `\\x%x'.\n", optopt);
           print_usage(argc, argv);
          }
        return 1;
      default:
        	abort();
      }


	if (device == NULL)
		pcap_fatal("pcap_lookupdev", errbuf);
		
	printf("Sniffing on device %s for %d packages\n", device, pack_count);
	
	pcap_handle = pcap_open_live(device, 4096, 1, 0, errbuf);
	if (pcap_handle == NULL)
		pcap_fatal("pcap_open", errbuf);
	
	pcap_loop(pcap_handle, pack_count, caught_packet, NULL);
	
	pcap_close(pcap_handle);
			
	return 1;
}

void print_usage(int argc, char *argv[]) {
	printf("Usage: %s [-d device | -c packets] \n", argv[0]);
}

void caught_packet(u_char *user_args, const struct pcap_pkthdr *cap_header, 
	const u_char *packet) {
	
	int tcp_header_length, total_header_length, pkt_data_len;
	u_char *pkt_data;
	
	printf("==== Got a %d byte packet ====\n", cap_header->len);
	
	decode_ethernet(packet);
	decode_ip(packet+ETHER_HDR_LEN);
	tcp_header_length = decode_tcp(packet+ETHER_HDR_LEN+sizeof(struct ip_hdr));
	
	total_header_length=ETHER_HDR_LEN+sizeof(struct ip_hdr)+tcp_header_length;
	pkt_data = (u_char *)packet+total_header_length;
	pkt_data_len=cap_header->len-total_header_length;
	
	if (pkt_data_len > 0) {
		printf("\t\t\t%u bytes of packet data\n", pkt_data_len);
		dump(pkt_data, pkt_data_len, 3);
	} else {
		printf("\t\t\tNo packet data\n");
	}
}

void pcap_fatal(const char *failed_in, const char *errbuf) {
	printf("[!!] Fatal error in %s: %s\n", failed_in, errbuf);
	exit(EXIT_FAILURE);
}

void decode_ethernet(const u_char *header_start) {
	int i;
	const struct ether_hdr *ethernet_header;
	
	ethernet_header = (const struct ether_hdr *)header_start;
	printf("[[ Layer 2 :: Ethernet Header ]]\n");
	printf("[ Source: %02x", ethernet_header->ether_src_addr[0]);
	for (i=1; i<ETHER_ADDR_LEN; i++)	
		printf(":%02x", ethernet_header->ether_src_addr[i]);
	
	printf("\tDest : %02x", ethernet_header->ether_dst_addr[0]);
	for (i=1; i<ETHER_ADDR_LEN; i++)	
		printf(":%02x", ethernet_header->ether_dst_addr[i]);
	
	printf("\tType: %hu ]\n", ethernet_header->ether_type);		
}

void decode_ip(const u_char *header_start) {
	int i;
	const struct ip_hdr *ip_header;
	 struct in_addr src_addr, dst_addr;
	
	ip_header = (const struct ip_hdr *)header_start;
	
	src_addr.s_addr = (ip_header->ip_src_addr);
	dst_addr.s_addr = (ip_header->ip_dst_addr);
	
	printf("\t(( Layer 3 :: IP Header ))\n");
	printf("\t( Source: %s", inet_ntoa(src_addr));
	printf("\tDest : %s)\n", inet_ntoa(dst_addr));
	
	printf("\t(Type: %u\t", (u_int) ip_header->ip_type);
	printf("ID: %hu\tLength: %hu)\n", 
		ntohs(ip_header->ip_id), ntohs(ip_header->ip_len)); 		
}

u_int decode_tcp(const u_char *header_start) {
	u_int header_size;
	const struct tcp_hdr *tcp_header;
	
	tcp_header = (const struct tcp_hdr *)header_start;
	header_size=4*tcp_header->tcp_offset;
	
	printf("\t\t{{ Layer 4 :: TCP Header }}\n");
	printf("\t\t{ Src Port: %hu", ntohs(tcp_header->tcp_src_port));
	printf("\tDest Port: %hu }\n", ntohs(tcp_header->tcp_dst_port));
	printf("\t\t{ Seq #: %u", ntohs(tcp_header->tcp_seq));
	printf("\tAck #: %u }\n", ntohs(tcp_header->tcp_ack));
	printf("\t\t{ Header Size: %u\t Flags: ", header_size);
	if (tcp_header->tcp_flags & TCP_FIN)
		printf("FIN ");
	if (tcp_header->tcp_flags & TCP_SYN)
		printf("SYN ");
	if (tcp_header->tcp_flags & TCP_RST)
		printf("RST ");
	if (tcp_header->tcp_flags & TCP_PUSH)
		printf("PUSH ");
	if (tcp_header->tcp_flags & TCP_ACK)
		printf("ACK ");
	if (tcp_header->tcp_flags & TCP_URG)
		printf("URG ");
	printf("}\n");
	
	return header_size;		
}

